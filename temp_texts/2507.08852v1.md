5 2 0 2

l u J

8

] h p - m e h c . s c i s y h p [

1 v 2 5 8 8 0 . 7 0 5 2 : v i X r a

Open, Reproducible Calculation of Assembly Indices

DEVANSH VIMAL, Arizona State University, USA GARRETT PARZYCH, Arizona State University, USA OLIVIA M. SMITH, Arizona State University, USA DEVENDRA PARKAR, Arizona State University, USA SEAN BERGEN, Arizona State University, USA JOSHUA J. DAYMUDE, Arizona State University, USA COLE MATHIS, Arizona State University, USA

We present assembly-theory, a Rust package for computing assembly indices of covalently bonded molecular structures. This is a key complexity measure of assembly theory, a recent theoretical framework quantifying selection across diverse systems, most importantly chemistry [17, 19]. assembly-theory is designed for researchers and practitioners alike, providing (i) extensible, high-performance implementations of assembly index calculation algorithms, (ii) comprehensive benchmarks against which current and future algorithmic improvements can be tested, and (iii) Python bindings and RDKit-compatible data loaders to support integration with existing computational pipelines.

1 BACKGROUND

Assembly theory (AT) is a recently developed body of theoretical and empirical work focused on characterizing selection in diverse physical systems, most importantly in chemistry [17, 19]. Objects are defined in AT as entities that are finite, distinguishable, decomposable, and persistent in time. AT characterizes objects based on their assembly index, the minimum number of recursive subconstructions required to construct the object starting from a given set of building blocks [5, 16]. The most commonly studied application domain of AT to date is molecular chemistry, where bonds act as the basic building blocks and the quantity of interest is the molecular assembly index (MA); see Fig. 1 for an example. It has previously been shown that MA can be measured for covalently- bonded molecules using standard analytical techniques such as tandem mass spectrometry as well as infrared and nuclear magnetic resonance spectroscopy [5], enabling a novel approach to life detection based on AT [12]. Beyond life detection, AT and MA have been proposed in methods to generate novel therapeutic drugs, identify environmental pollutants, and gain new insights into evolutionary history by inferring relationships directly from metabolomic data [6, 11].

2 STATEMENT OF NEED

Despite AT’s promising applications, computing MA efficiently remains a challenge. In general, exact MA calculation is an NP-hard problem [10]; i.e., the necessary computing resources are likely to grow exponentially with a molecule’s number of bonds. Previous software to compute MA have been

Authors’ addresses: Devansh Vimal, Arizona State University, Biodesign Center for Biocomputing, Security and Society, 727 E. Tyler St., Tempe, AZ, 85281, USA, dvpatel5@asu.edu; Garrett Parzych, Arizona State University, Biodesign Center for Biocomputing, Security and Society, School of Computing and Augmented Intelligence, 727 E. Tyler St., Tempe, AZ, 85281, USA, gparzych@asu.edu; Olivia M. Smith, Arizona State University, Biodesign Center for Biocomputing, Security and Society, School of Complex Adaptive Systems, 727 E. Tyler St., Tempe, AZ, 85281, USA, omsmith8@asu.edu; Devendra Parkar, Arizona State University, Biodesign Center for Biocomputing, Security and Society, School of Computing and Augmented Intelligence, 727 E. Tyler St., Tempe, AZ, 85281, USA, dparkar1@asu.edu; Sean Bergen, Arizona State University, Biodesign Center for Biocomputing, Security and Society, School of Computing and Augmented Intelligence, 727 E. Tyler St., Tempe, AZ, 85281, USA, sbergen2@asu.edu; Joshua J. Daymude, Arizona State University, Biodesign Center for Biocomputing, Security and Society, School of Computing and Augmented Intelligence, 727 E. Tyler St., Tempe, AZ, 85281, USA, jdaymude@asu.edu; Cole Mathis, Arizona State University, Biodesign Center for Biocomputing, Security and Society, School of Complex Adaptive Systems, 727 E. Tyler St., Tempe, AZ, 85281, USA, nmathis@asu.edu.













2

Vimal, Parzych, Smith, Parkar, Bergen, Daymude, and Mathis

Fig. 1. Assembly Pathways for Anthracene. Starting with bonds as building blocks (yellow), a joining operation yields progressively larger structures by combining any two compatible structures that have already been constructed (arrows). These intermediate structures must obey valence rules but otherwise do not have to be physically accessible or chemically synthesizable. There may be many assembly pathways from building blocks to a target structure—in this case, Anthracene (green)—but the length of any shortest such pathway (blue) is that structure’s assembly index.

approximate, closed-source, platform-dependent, or written in languages rarely used by the broader scientific community. For example, the original software to compute a split-branch approximation of MA (an upper bound on the exact value) was written in C++ and depended on the MSVC compiler, making it difficult to deploy to non-Windows machines [12]. Machine learning methods only provide approximate MA values [4]. The more recent assembly_go implementation computes MA exactly but is written in Go, yielding worse performance and posing an accessibility barrier for most scientists who are unfamiliar with the language [5]. Finally, the latest implementation achieves significant performance milestones through a branch-and-bound approach [16]. It is again written in C++ but is not publicly available, prohibiting its use and verification by the community. With assembly-theory, we provide a high-performance Rust package for MA calculation while also providing Python bindings for key functionality, offering the best efficiency without sacrificing ease of use for scientific practitioners. We chose Rust for its advantages of cross-platform support, memory-safety, performant runtime, convenient parallelism, and integrated testing and documen- tation [14]. By including test and benchmark suites, we also lay a foundation for fair, reproducible comparisons of future algorithmic improvements.

3 DESIGN AND CURRENT ALGORITHMS assembly-theory is not a single algorithmic implementation of assembly index calculations; rather, it is a framework and source of ground truth within which a diversity of algorithmic approaches can be validated and compared. We purposely designed assembly-theory with a modular algorithm interface and data structures that can be easily extended to handle new algorithmic developments introduced as AT matures.

Building Blocks(Bonds)Minimum-length Path(6 Steps)Candidate Path(7 Steps)Target Structure(Input Molecule)Open, Reproducible Calculation of Assembly Indices

3

Following prior work [5, 12, 16], assembly-theory currently implements a top-down approach with two phases that execute in sequence: (1) a search space enumeration and (2) a parallel branch- and-bound search. The enumeration phase finds all pairs of isomorphic, edge-disjoint subgraphs of the given molecule. Isomorphic subgraphs are binned into equivalence classes by their nauty canonical representations [13] and pairs of subgraphs within the same class are yielded if they are edge-disjoint. In the search phase, the given molecule is recursively fragmented by removing duplicate subgraphs enumerated in the first phase. The MA of smaller fragments are used to determine the MA of their parents. Optionally, a bounding strategy can be used to improve search efficiency. We briefly summarize the implemented branch-and-bound ("bb") variants below, but emphasize that assembly-theory is not limited to this top-down, recursive approach.

• bb-naive fully enumerates all non-duplicate assembly pathways to find the shortest one. • bb-logbound improves over the naive method by eliminating any assembly pathways 𝑏 exceeds the length of the shortest assembly pathway found

whose current length plus log2 so far, where 𝑏 is the number of remaining bonds [5].

• bb-intbound uses a stronger lower bound on the number of remaining assembly steps

provided by an integer addition chain [16].

• bb-allbounds simultaneously applies the previous integer addition chain bound and a

novel bound provided by a vector addition chain.

4 FUNCTIONALITY AND USAGE EXAMPLES assembly-theory can be used to compute assembly indices as a standalone executable, as a library imported by other Rust code, or via a Python interface. Here, we provide usage examples of each; in the next section, we demonstrate testing and benchmarking functionality.

4.1 Standalone Executable Rust provides the cargo build system and package manager for dependency management, compila- tion, packaging, and versioning and the crates.io registry for package distribution. To install the standalone executable, run:

> cargo install assembly-theory

This executable takes as input a path to a .mol file and returns that molecule’s assembly index:

> assembly-theory data/checks/anthracene.mol 6

Running with the --verbose flag provides additional information, including the input molecule’s number of disjoint, isomorphic subgraph pairs (i.e., the number of times any molecular substructure is repeated inside the molecule) and the size of the top-down algorithm’s search space (i.e., its total number of recursive calls).

> assembly-theory data/checks/anthracene.mol --verbose Assembly Index: 6 Duplicate subgraph pairs: 406 Search Space: 2306

By default, assembly-theory parallelizes its recursive search over as many threads as the OS allows. To disable parallelism, use the --serial flag.

4

Vimal, Parzych, Smith, Parkar, Bergen, Daymude, and Mathis

Also by default, assembly-theory uses its fastest algorithm for assembly index calculation (cur- rently bb-allbounds, see the previous section). To use a specific bound or disable bounds altogether, set the --bounds or --no-bounds flags:

# bb-naive, no bounds > assembly-theory data/checks/anthracene.mol --no-bounds

# bb-logbound, only logarithmic bound (Jirasek et al., 2024) > assembly-theory data/checks/anthracene.mol --bounds log

# bb-intbound, only integer addition chain bound (Seet et al., 2024) > assembly-theory data/checks/anthracene.mol --bounds int-chain

# bb-allbounds, both integer and vector addition chain bounds > assembly-theory data/checks/anthracene.mol --bounds int-chain vec-chain

Finally, the --molecule-info flag prints the molecule’s graph representation as a vertex and edge list, the --help flag prints a guide to this command line interface, and the --version flag prints the current assembly-theory version.

4.2 Rust Library To include assembly-theory in a broader Rust project, run:

> cargo add assembly-theory

Complete documentation of the library is available on docs.rs; a simple usage example is:

use assembly_theory::*;

// Read a .mol file as an assembly_theory::molecule::Molecule. let molfile = fs::read_to_string(path)?; let anthracene = loader::parse_molfile_str(&molfile).expect("Parsing failed");

// Calculate the molecule's assembly index. assert_eq!(assembly::index(&anthracene), 6);

4.3 Python Interface We use maturin to repackage the assembly-theory Rust binaries as the assembly_theory package for Python. Instructions for this build process can be found in our README; otherwise, the Python package can be obtained from PyPI in the usual way:

> pip install assembly_theory

Our Python interface is built for compatibility with RDKit, the standard Python library for chemin- formatics [1]. Molecules can be loaded and manipulated using the rdkit.Chem.Mol class and then passed to our functions for assembly index calculation:

>>> import assembly_theory as at >>> from rdkit import Chem >>> anthracene = Chem.MolFromSmiles("c1ccc2cc3ccccc3cc2c1") >>> at.molecular_assembly(anthracene) 6

Open, Reproducible Calculation of Assembly Indices

5

In detail, assembly_theory exposes three main functions:

(1) molecular_assembly(mol: Chem.Mol, bounds: set[str] = None, no_bounds: bool

= False, timeout: int = None, serial: bool = False) -> int

(2) molecular_assembly_verbose(mol: Chem.Mol, bounds: set[str] = None, no_bounds:

bool = False, timeout: int = None, serial: bool = False) -> dict

(3) molecule_info(mol: Chem.Mol) -> str

These correspond to (1) running the Rust assembly-theory executable to obtain only an assembly index, (2) running with the --verbose flag to also obtain the number of disjoint isomorphic sub- graph pairs (duplicates) and search space size (space), and (3) running with the --molecule-info flag to obtain molecule information, respectively. The timeout parameter is specific to the Python interface: when set to a non-None integer value, a TimeoutError is raised if assembly index calcu- lation exceeds timeout seconds.

5 TESTS AND BENCHMARKS assembly-theory includes test and benchmark suites for software validation and performance evaluation, respectively. Both use curated reference datasets representing different classes of molecules, arranged roughly in order of increasing molecular size and complexity:

• gdb13_1201: 1,201 small, organic molecular structures sampled from GDB-13, a database of enumerated chemical structures containing Carbon, Hydrogen, Nitrogen, Oxygen, Sulfur, and Chlorine that are constrained only by valence rules and quantum mechanics but may not be chemically stable or synthesizable [2]. Our sample includes all 201 molecules with 4–5 heavy atoms and 200 randomly sampled molecules for each number of heavy atoms from 6–10. These molecules’ MA range from 2–9.

• gdb17_200: 200 organic molecular structures sampled from the GDB-17 database, which includes additional nuclei beyond GDB-13 such as the halogens Flourine and Iodine [15]. Compared to GDB-13, these molecules are typically larger and represent more structural diversity. Our sample includes 50 randomly sampled molecules for each number of heavy atoms from 14–17. These molecules’ MA range from 7–16.

• checks: 15 named molecules (e.g., anthracene, aspirin, caffeine, morphine) from KEGG COMPOUND [7–9] primarily used for rapid testing. These molecules’ number of heavy atoms range from 5–21 and have MA from 3–14.

• coconut_55: 55 natural products sampled from the COCONUT database [18], accessed in late 2024, prior to COCONUT 2.0 [3]. Natural products (or secondary metabolites) are a rich source of evolved chemical complexity, often exhibiting drug-like properties. Subsets of this database were used to benchmark recent algorithmic progress in [16]. Our sample includes five randomly sampled molecules for each number of heavy atoms from 15–25. These molecules’ MA range from 7–16.

We curated these reference datasets for their structural diversity and approachable runtime on commodity hardware. Larger, more demanding datasets can be added as needed. The assembly-theory test suite contains unit tests validating internal functionality and integration tests verifying the calculation of correct assembly indices for all molecules in our reference datasets. Each reference dataset contains an ma-index.csv file with ground truth assembly indices calculated using the closed-source [16] algorithm, privately provided to us by the authors for this use only.

6

Vimal, Parzych, Smith, Parkar, Bergen, Daymude, and Mathis

Table 1. Mean benchmark execution times for assembly_go [5] vs. assembly-theory across reference datasets. The benchmark times the MA calculation of all molecules in a given dataset in sequence, excluding the time required to parse and load .mol files into internal molecular graph representations. assembly_go uses its default parameters while assembly-theory tests each of its algorithm variants independently. Each benchmark was run on a Linux machine with a 5.7 GHz Ryzen 9 7950X CPU (16 cores) and 64 GB of memory. Means are reported over 20 samples per software–dataset pair, except those marked with an ∗ which have prohibitively long runtimes and thus ran only once.

assembly_go

bb-naive

bb-logbound

bb-intbound

bb-allbounds

gdb13_1201 gdb17_200 checks coconut_55

0.968 s 46.189 s 212.000 s 1.48 h∗

0.147 s 4.586 s 12.635 s 175.687 s

0.149 s 3.446 s 1.767 s 57.123 s

0.140 s 2.988 s 1.357 s 13.188 s

0.142 s 2.946 s 1.297 s 12.996 s

Our benchmark suite evaluates assembly-theory performance by running repeated assembly index calculations over individual molecules or entire reference datasets. We leverage the criterion pack- age for Rust to automatically collect detailed timing statistics, charts, and estimates of performance improvements and regressions. As an example, Table 1 shows assembly-theory performance across our four reference datasets against that of assembly_go [5]. Depending on the dataset and choice of assembly-theory algorithm, assembly-theory outperforms assembly_go by one or two orders of magnitude. The 6.5–120.0x speedup of bb-logbound over assembly_go most clearly represents the efficiency of Rust over Go, since both use the same branch-and-bound approach with a logarithmic bound. Algorithmic improvements such as the bb-allbounds combination of an integer addition chain bound [16] and our novel vector addition chain bound yield more dramatic speedups for larger molecules, like those up to 410.0x for coconut_55. This internal comparison showcases assembly-theory as a framework capable of comparing multiple algorith- mic approaches on equal footing, free of differences in underlying datasets or language-specific efficiency issues. If finer-grained timing insights are needed, assembly-theory can also benchmark assembly in- dex calculations for each individual molecule in a reference dataset. For example, Fig. 2 shows the calculation time of each molecule in gdb17_200 for the four branch-and-bound algorithms. This is useful for teasing out which molecules are "hard" and characterizing where algorithmic improvements make the largest impact.

6 AVAILABILITY AND GOVERNANCE assembly-theory source code and documentation are openly available on GitHub. Following the standard practice for Rust packages, assembly-theory is dual-licensed under the MIT and Apache-2.0 licenses. External feedback and code contributions are handled through the usual Issues and Pull Request interfaces; guidelines for contributions are listed in HACKING.md. The project’s maintainers (initially Vimal, Daymude, and Mathis) will govern the project using the committee model: high-level decisions about the project’s direction require maintainer consensus, major code changes require majority approval, hotfixes and patches require at least one approval, new maintainers may be added by unanimous decision of the existing maintainers, and existing maintainers may step down with advance notice.

Open, Reproducible Calculation of Assembly Indices

7

Fig. 2. Per-Molecule Benchmark Times. The mean assembly index calculation time across 20 samples for each molecule (dot) in gdb17_200 as a function of the molecule’s number of duplicate isomorphic subgraphs, a measure roughly correlated with the molecule’s size and complexity. The same four assembly-theory branch-and-bound algorithms from Fig. 1 are shown here.

AUTHOR CONTRIBUTIONS

GP, DV, and CM formalized the branch-and-bound algorithm design. GP and SB formalized the integer and vector addition chain bounds. DV was the primary software developer (architecture, command line interface, molecule representations, unit tests, parallelism, performance engineering). GP implemented all bound calculations. DP and DV implemented the .mol file parser and dataset- based benchmarks. CM implemented the Python interface. OMS curated all reference datasets and assembly index ground truths with input from CM. SB and JJD wrote the assembly_go benchmarks. JJD conducted and analyzed the benchmarks shown in Table 1. DP, SB, GP, and JJD produced Fig. 2. JJD and CM wrote the paper.

ACKNOWLEDGMENTS

GP and JJD are supported in part by NSF award CCF-2312537. DV, OMS, and CM acknowledge support from the ASU Biodesign Institute.

REFERENCES

[1] 2024. RDKit: Open-Source Cheminformatics. https://doi.org/10.5281/zenodo.591637 [2] Lorenz C. Blum and Jean-Louis Reymond. 2009. 970 Million Druglike Small Molecules for Virtual Screening in the Chemical Universe Database GDB-13. Journal of the American Chemical Society 131, 25 (2009), 8732–8733. https://doi.org/10.1021/ja902302h

[3] Venkata Chandrasekhar, Kohulan Rajan, Sri Ram Sagar Kanakam, Nisha Sharma, Viktor Weißenborn, Jonas Schaub, and Christoph Steinbeck. 2025. COCONUT 2.0: A Comprehensive Overhaul and Curation of the Collection of Open Natural Products Database. Nucleic Acids Research 53, D1 (2025), D634–D643. https://doi.org/10.1093/nar/gkae1063

050010001500200025003000# Disjoint Isomorphic Subgraph Pairs103102101Assembly Index Calculation Time (seconds, log scale)bb-naivebb-logboundbb-intboundbb-allbounds8

Vimal, Parzych, Smith, Parkar, Bergen, Daymude, and Mathis

[4] Timothy D. Gebhard, Aaron C. Bell, Jian Gong, Jaden J. A. Hastings, G. Matthew Fricke, Nathalie Cabrol, Scott Sandford, Michael Phillips, Kimberley Warren-Rhodes, and Atılım Güneş Baydin. 2022. Inferring Molecular Complexity from Mass Spectrometry Data Using Machine Learning. In Machine Learning and the Physical Sciences Workshop at NeurIPS 2022. 1–7.

[5] Michael Jirasek, Abhishek Sharma, Jessica R. Bame, S. Hessam M. Mehr, Nicola Bell, Stuart M. Marshall, Cole Mathis, Alasdair MacLeod, Geoffrey J. T. Cooper, Marcel Swart, Rosa Mollfulleda, and Leroy Cronin. 2024. Investigating and Quantifying Molecular Complexity Using Assembly Theory and Spectroscopy. ACS Central Science 10, 5 (2024), 1054–1064. https://doi.org/10.1021/acscentsci.4c00120

[6] Amit Kahana, Alasdair MacLeod, Hessam Mehr, Abhishek Sharma, Emma Carrick, Michael Jirasek, Sara I. Walker, and Leroy Cronin. 2024. Constructing the Molecular Tree of Life Using Assembly Theory and Mass Spectrometry. https://doi.org/10.48550/arxiv.2408.09305 arXiv:2408.09305

[7] Minoru Kanehisa. 2019. Toward Understanding the Origin and Evolution of Cellular Organisms. Protein Science 28, 11

(2019), 1947–1951. https://doi.org/10.1002/pro.3715

[8] Minoru Kanehisa, Miho Furumichi, Yoko Sato, Masayuki Kawashima, and Mari Ishiguro-Watanabe. 2023. KEGG for Taxonomy-Based Analysis of Pathways and Genomes. Nucleic Acids Research 51, D1 (2023), D587–D592. https: //doi.org/10.1093/nar/gkac963

[9] Minoru Kanehisa and Susumu Goto. 2000. KEGG: Kyoto Encyclopedia of Genes and Genomes. Nucleic Acids Research

28, 1 (2000), 27–30. https://doi.org/10.1093/nar/28.1.27

[10] Christopher Kempes, Sara I. Walker, Michael Lachmann, and Leroy Cronin. 2024. Assembly Theory and Its Relationship

with Computational Complexity. https://doi.org/10.48550/arXiv.2406.12176 arXiv:2406.12176

[11] Yu Liu, Cole Mathis, Michał Dariusz Bajczyk, Stuart M. Marshall, Liam Wilbraham, and Leroy Cronin. 2021. Exploring and Mapping Chemical Space with Molecular Assembly Trees. Science Advances 7, 39 (2021), eabj2465. https: //doi.org/10.1126/sciadv.abj2465

[12] Stuart M. Marshall, Cole Mathis, Emma Carrick, Graham Keenan, Geoffrey J. T. Cooper, Heather Graham, Matthew Craven, Piotr S. Gromski, Douglas G. Moore, Sara. I. Walker, and Leroy Cronin. 2021. Identifying Molecules as Biosignatures with Assembly Theory and Mass Spectrometry. Nature Communications 12, 1 (2021), 3033. https: //doi.org/10.1038/s41467-021-23258-x

[13] Brendan D. McKay and Adolfo Piperno. 2014. Practical Graph Isomorphism, II. Journal of Symbolic Computation 60

(2014), 94–112. https://doi.org/10.1016/j.jsc.2013.09.003

[14] Jeffrey M. Perkel. 2020. Why Scientists Are Turning to Rust. Nature 588, 7836 (2020), 185–186. https://doi.org/10.

1038/d41586-020-03382-2

[15] Lars Ruddigkeit, Ruud Van Deursen, Lorenz C. Blum, and Jean-Louis Reymond. 2012. Enumeration of 166 Billion Organic Small Molecules in the Chemical Universe Database GDB-17. Journal of Chemical Information and Modeling 52, 11 (2012), 2864–2875. https://doi.org/10.1021/ci300415d

[16] Ian Seet, Keith Y. Patarroyo, Gage Siebert, Sara I. Walker, and Leroy Cronin. 2024. Rapid Computation of the Assembly

Index of Molecular Graphs. https://doi.org/10.48550/arXiv.2410.09100 arXiv:2410.09100

[17] Abhishek Sharma, Dániel Czégel, Michael Lachmann, Christopher P. Kempes, Sara I. Walker, and Leroy Cronin. 2023. Assembly Theory Explains and Quantifies Selection and Evolution. Nature 622, 7982 (2023), 321–328. https: //doi.org/10.1038/s41586-023-06600-9

[18] Maria Sorokina, Peter Merseburger, Kohulan Rajan, Mehmet Aziz Yirik, and Christoph Steinbeck. 2021. COCONUT Online: Collection of Open Natural Products Database. Journal of Cheminformatics 13, 1 (2021), 2. https://doi.org/10. 1186/s13321-020-00478-9

[19] Sara I. Walker, Cole Mathis, Stuart Marshall, and Leroy Cronin. 2024. Experimentally Measured Assembly Indices Are Required to Determine the Threshold for Life. Journal of The Royal Society Interface 21, 220 (2024), 20240367. https://doi.org/10.1098/rsif.2024.0367

